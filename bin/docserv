#!/usr/bin/env python3

import json
import time
import subprocess
import shlex
import datetime
import os
import sys
import threading
import queue
import socket
import configparser
import logging
import signal
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
my_env = os.environ

class Documentation:
    def __init__(self, doc_params, config):
        if self.validate(doc_params, config):
            self.doc_params = doc_params
            self.config = config
            self.initialized = True
            for target in doc_params['targets']:
                if not self.read_conf_dir(target):
                    self.initialized = False
            return
        self.initialized = False

    def read_conf_dir(self, target):
        # validate with sknorrs magic bash script
        cmd = '/usr/bin/docserv-stitch %s' % self.config['targets'][target]['config_dir']
        logger.debug("Stitching %s" % cmd)
        cmd = shlex.split(cmd)
        s = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        s.communicate()[0]
        rc = int(s.returncode)
        if rc == 0:
            logger.debug("Stitching of %s successful" % self.config['targets'][target]['config_dir'])
        else:
            logger.warning("Stitching of %s failed!" % self.config['targets'][target]['config_dir'])
        # then read all files into an xml tree
        pass

    def validate(self, item, config):
        # item = {'docs': [{'docset': '15ga', 'lang': 'en', 'product': 'sles'}],'targets': ['external']}
        logger.debug("Validation: %s" % json.dumps(item))
        if not isinstance(item, dict):
            logger.warning("Validation: Is not a dict")
            return False
        if not isinstance(item['targets'], list):
            logger.warning("Validation: targets is not a list")
            return False
        if not isinstance(item['docs'], list):
            logger.warning("Validation: docs is not a list")
            return False
        for doc in item['docs']:
            if not isinstance(doc['docset'], str):
                logger.warning("Validation: docset is not a string")
                return False
            if not isinstance(doc['lang'], str):
                logger.warning("Validation: lang is not a string")
                return False
            if not isinstance(doc['product'], str):
                logger.warning("Validation: product is not a string")
                return False
        for target in item['targets']:
            if target in config['targets']:
                pass
            else:
                logger.warning("Validation: target %s does not exist" % target)
                return False
        logger.debug("Valid doc: %s" % json.dumps(doc))
        return True


class Docserv:
    def __init__(self, argv):
        self.waiting_for_build = queue.Queue()
        self.currently_building = queue.Queue()
        self.end_end_all = queue.Queue()
        self.parse_config(argv)
    
    def parse_config(self, argv):
        config = configparser.ConfigParser()
        if len(argv) == 1:
            argv[1] = "docserv"
        logger.info("Reading /etc/docserv/%s.ini" % argv[1])
        config.read("/etc/docserv/%s.ini" % argv[1])
        LOGLEVELS = {0: logging.WARNING,
             1: logging.INFO,
             2: logging.DEBUG,
        }
        self.config = {}
        self.config['server'] =                 {}
        self.config['server']['loglevel'] =     int(config['server']['loglevel'])
        logger.setLevel(LOGLEVELS[self.config['server']['loglevel']])
        self.config['server']['host'] =         config['server']['host']
        self.config['server']['port'] =         int(config['server']['port'])
        self.config['server']['repo_dir'] =     config['server']['repo_dir']
        self.config['server']['max_threads'] =  int(config['server']['max_threads'])
        self.config['targets'] =                {}
        for section in config.sections():
            if not str(section).startswith("target_"):
                continue
            self.config['targets'][config[section]['name']] =                  {}
            self.config['targets'][config[section]['name']]['type'] =          config[section]['type']
            self.config['targets'][config[section]['name']]['templdate_dir'] = config[section]['template_dir']
            self.config['targets'][config[section]['name']]['active'] =        config[section]['active']
            self.config['targets'][config[section]['name']]['target_repo'] =   config[section]['target_repo']
            self.config['targets'][config[section]['name']]['config_dir'] =    config[section]['config_dir']

    def start(self):
        # start everything
        try:
            thread_receive = threading.Thread(target=self.listen)
            thread_receive.start()
            thread_builds = []
            for i in range(0,min([os.cpu_count(), self.config['server']['max_threads']])):
                logger.info("Starting build thread %i" % i)
                thread_builds.append(threading.Thread(target=self.build, args=(i,)))
                thread_builds[i].start()
            # to have a clean shutdown, wait for all threads to finish
            thread_receive.join()
        except KeyboardInterrupt:
            self.exit()
        for thread_build in thread_builds:
            thread_build.join()

    def exit(self):
        logger.info("Exiting now")
        self.end_end_all.put("now")
        self.rest.shutdown()

    def get_item(self):
        try:
            build_item = self.waiting_for_build.get(block=False)
        except queue.Empty:
            return None
        return build_item

    def build(self, thread_id):
        while( True ):
            build_item = self.get_item()
            if build_item is not None:
                logger.debug("Thread %i: Got item" % thread_id)
                doc = Documentation(build_item, self.config)
            else:
                logger.debug("Thread %i: No item" % thread_id)
            """
            section = self.queued_docs.get(block=True, timeout=None)
            building_docs.put(section)
            timestamp = False
            if build(section) == 0:
                timestamp = time.strftime( '%Y-%m-%d %H:%M:%S' )
            finished_docs.put((section, timestamp))
            cmd = '/suse/lxbuch/doc/daps-autobuild/daps-autobuild --config /suse/lxbuch/doc/daps-autobuild/daps-autobuild_docserv.xml --schema /suse/lxbuch/doc/daps-autobuild/daps-autobuild.rnc --notify --sections %s' % section
            cmd = shlex.split(cmd)
            s = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            s.communicate()[0]
            rc = s.returncode
            cmd = '/suse/lxbuch/doc/portwinestain/portwinestain'
            cmd = shlex.split(cmd)
            s = subprocess.Popen(cmd)
            s.wait()
            """
            if not self.end_end_all.empty(): return True
            time.sleep(10)

    def listen(self):
        server_address = (self.config['server']['host'], int(self.config['server']['port']))
        self.rest = ThreadedRESTServer(server_address, RESTServer, self.waiting_for_build, self.currently_building)
        self.rest.serve_forever()
        return True

class RESTServer(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
    def do_GET(self):
        self._set_headers()
        output = {}
        output['waiting_for_build'] = [] if self.server.waiting_for_build.empty() else list(self.server.waiting_for_build.queue)
        output['currently_building'] = [] if self.server.currently_building.empty() else list(self.server.currently_building.queue)
        self.wfile.write(bytes(json.dumps(output), "utf-8"))
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        data = json.loads(post_data)
        for doc in data:
            logger.info("Queueing %s" % json.dumps(doc))
            self.server.waiting_for_build.put(doc)
        self._set_headers()

class ThreadedRESTServer(ThreadingMixIn, HTTPServer):
    def __init__(self, server_address, RequestHandlerClass, waiting_for_build, currently_building, bind_and_activate=True):
        HTTPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate)
        logger.info("Starting HTTP server on %s:%i" % server_address)
        self.waiting_for_build = waiting_for_build
        self.currently_building = currently_building

logger = logging.getLogger('docserv')

ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

if __name__ == "__main__":
    docserv = Docserv(sys.argv)
    docserv.start()
